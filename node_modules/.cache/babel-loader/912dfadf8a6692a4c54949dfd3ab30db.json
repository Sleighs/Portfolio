{"ast":null,"code":"import React, { forwardRef, useRef, useState, useEffect, useMemo, useCallback, useImperativeHandle, useLayoutEffect } from 'react';\nimport { omit } from 'jerrypick';\nimport fromEntries from 'fromentries';\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (null != _i) {\n    var _s,\n        _e,\n        _x,\n        _r,\n        _arr = [],\n        _n = !0,\n        _d = !1;\n\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction index(kapsuleComponent, comboParam) {\n  var _ref = _typeof(comboParam) === 'object' ? comboParam : {\n    // support old schema for backwards compatibility\n    wrapperElementType: comboParam,\n    methodNames: (arguments.length <= 2 ? undefined : arguments[2]) || undefined,\n    initPropNames: (arguments.length <= 3 ? undefined : arguments[3]) || undefined\n  },\n      _ref$wrapperElementTy = _ref.wrapperElementType,\n      wrapperElementType = _ref$wrapperElementTy === void 0 ? 'div' : _ref$wrapperElementTy,\n      _ref$nodeMapper = _ref.nodeMapper,\n      nodeMapper = _ref$nodeMapper === void 0 ? function (node) {\n    return node;\n  } : _ref$nodeMapper,\n      _ref$methodNames = _ref.methodNames,\n      methodNames = _ref$methodNames === void 0 ? [] : _ref$methodNames,\n      _ref$initPropNames = _ref.initPropNames,\n      initPropNames = _ref$initPropNames === void 0 ? [] : _ref$initPropNames;\n\n  return /*#__PURE__*/forwardRef(function (props, ref) {\n    var domEl = useRef();\n\n    var _useState = useState({}),\n        _useState2 = _slicedToArray(_useState, 2),\n        prevProps = _useState2[0],\n        setPrevProps = _useState2[1];\n\n    useEffect(function () {\n      return setPrevProps(props);\n    }); // remember previous props\n    // instantiate the inner kapsule component with the defined initPropNames\n\n    var comp = useMemo(function () {\n      var configOptions = fromEntries(initPropNames.filter(function (p) {\n        return props.hasOwnProperty(p);\n      }).map(function (prop) {\n        return [prop, props[prop]];\n      }));\n      return kapsuleComponent(configOptions);\n    }, []);\n    useEffectOnce(function () {\n      comp(nodeMapper(domEl.current)); // mount kapsule synchronously on this element ref, optionally mapped into an object that the kapsule understands\n    }, useLayoutEffect);\n    useEffectOnce(function () {\n      // invoke destructor on unmount, if it exists\n      return comp._destructor instanceof Function ? comp._destructor : undefined;\n    }); // Call a component method\n\n    var _call = useCallback(function (method) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return comp[method] instanceof Function ? comp[method].apply(comp, args) : undefined;\n    } // method not found\n    , [comp]); // propagate component props that have changed\n\n\n    var dynamicProps = omit(props, [].concat(_toConsumableArray(methodNames), _toConsumableArray(initPropNames))); // initPropNames or methodNames should not be called\n\n    Object.keys(dynamicProps).filter(function (p) {\n      return prevProps[p] !== props[p];\n    }).forEach(function (p) {\n      return _call(p, props[p]);\n    }); // bind external methods to parent ref\n\n    useImperativeHandle(ref, function () {\n      return fromEntries(methodNames.map(function (method) {\n        return [method, function () {\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          return _call.apply(void 0, [method].concat(args));\n        }];\n      }));\n    });\n    return /*#__PURE__*/React.createElement(wrapperElementType, {\n      ref: domEl\n    });\n  });\n} //\n// Handle R18 strict mode double mount at init\n\n\nfunction useEffectOnce(effect) {\n  var useEffectFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : useEffect;\n  var destroyFunc = useRef();\n  var effectCalled = useRef(false);\n  var renderAfterCalled = useRef(false);\n\n  var _useState3 = useState(0),\n      _useState4 = _slicedToArray(_useState3, 2);\n\n  _useState4[0];\n  var setVal = _useState4[1];\n\n  if (effectCalled.current) {\n    renderAfterCalled.current = true;\n  }\n\n  useEffectFn(function () {\n    // only execute the effect first time around\n    if (!effectCalled.current) {\n      destroyFunc.current = effect();\n      effectCalled.current = true;\n    } // this forces one render after the effect is run\n\n\n    setVal(function (val) {\n      return val + 1;\n    });\n    return function () {\n      // if the comp didn't render since the useEffect was called,\n      // we know it's the dummy React cycle\n      if (!renderAfterCalled.current) return;\n      if (destroyFunc.current) destroyFunc.current();\n    };\n  }, []);\n}\n\nexport { index as default };","map":{"version":3,"sources":["/Users/samuelwright/Projects/portfolio/node_modules/react-kapsule/dist/react-kapsule.mjs"],"names":["React","forwardRef","useRef","useState","useEffect","useMemo","useCallback","useImperativeHandle","useLayoutEffect","omit","fromEntries","_iterableToArrayLimit","arr","i","_i","Symbol","iterator","_s","_e","_x","_r","_arr","_n","_d","call","next","Object","done","push","value","length","err","return","_typeof","obj","constructor","prototype","_slicedToArray","_arrayWithHoles","_unsupportedIterableToArray","_nonIterableRest","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","from","o","minLen","n","toString","slice","name","test","len","arr2","TypeError","index","kapsuleComponent","comboParam","_ref","wrapperElementType","methodNames","arguments","undefined","initPropNames","_ref$wrapperElementTy","_ref$nodeMapper","nodeMapper","node","_ref$methodNames","_ref$initPropNames","props","ref","domEl","_useState","_useState2","prevProps","setPrevProps","comp","configOptions","filter","p","hasOwnProperty","map","prop","useEffectOnce","current","_destructor","Function","_call","method","_len","args","_key","apply","dynamicProps","concat","keys","forEach","_len2","_key2","createElement","effect","useEffectFn","destroyFunc","effectCalled","renderAfterCalled","_useState3","_useState4","setVal","val","default"],"mappings":"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","sourcesContent":["import React, { forwardRef, useRef, useState, useEffect, useMemo, useCallback, useImperativeHandle, useLayoutEffect } from 'react';\nimport { omit } from 'jerrypick';\nimport fromEntries from 'fromentries';\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction index (kapsuleComponent, comboParam) {\n  var _ref = _typeof(comboParam) === 'object' ? comboParam : {\n      // support old schema for backwards compatibility\n      wrapperElementType: comboParam,\n      methodNames: (arguments.length <= 2 ? undefined : arguments[2]) || undefined,\n      initPropNames: (arguments.length <= 3 ? undefined : arguments[3]) || undefined\n    },\n    _ref$wrapperElementTy = _ref.wrapperElementType,\n    wrapperElementType = _ref$wrapperElementTy === void 0 ? 'div' : _ref$wrapperElementTy,\n    _ref$nodeMapper = _ref.nodeMapper,\n    nodeMapper = _ref$nodeMapper === void 0 ? function (node) {\n      return node;\n    } : _ref$nodeMapper,\n    _ref$methodNames = _ref.methodNames,\n    methodNames = _ref$methodNames === void 0 ? [] : _ref$methodNames,\n    _ref$initPropNames = _ref.initPropNames,\n    initPropNames = _ref$initPropNames === void 0 ? [] : _ref$initPropNames;\n  return /*#__PURE__*/forwardRef(function (props, ref) {\n    var domEl = useRef();\n    var _useState = useState({}),\n      _useState2 = _slicedToArray(_useState, 2),\n      prevProps = _useState2[0],\n      setPrevProps = _useState2[1];\n    useEffect(function () {\n      return setPrevProps(props);\n    }); // remember previous props\n\n    // instantiate the inner kapsule component with the defined initPropNames\n    var comp = useMemo(function () {\n      var configOptions = fromEntries(initPropNames.filter(function (p) {\n        return props.hasOwnProperty(p);\n      }).map(function (prop) {\n        return [prop, props[prop]];\n      }));\n      return kapsuleComponent(configOptions);\n    }, []);\n    useEffectOnce(function () {\n      comp(nodeMapper(domEl.current)); // mount kapsule synchronously on this element ref, optionally mapped into an object that the kapsule understands\n    }, useLayoutEffect);\n    useEffectOnce(function () {\n      // invoke destructor on unmount, if it exists\n      return comp._destructor instanceof Function ? comp._destructor : undefined;\n    });\n\n    // Call a component method\n    var _call = useCallback(function (method) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      return comp[method] instanceof Function ? comp[method].apply(comp, args) : undefined;\n    } // method not found\n    , [comp]);\n\n    // propagate component props that have changed\n    var dynamicProps = omit(props, [].concat(_toConsumableArray(methodNames), _toConsumableArray(initPropNames))); // initPropNames or methodNames should not be called\n    Object.keys(dynamicProps).filter(function (p) {\n      return prevProps[p] !== props[p];\n    }).forEach(function (p) {\n      return _call(p, props[p]);\n    });\n\n    // bind external methods to parent ref\n    useImperativeHandle(ref, function () {\n      return fromEntries(methodNames.map(function (method) {\n        return [method, function () {\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n          return _call.apply(void 0, [method].concat(args));\n        }];\n      }));\n    });\n    return /*#__PURE__*/React.createElement(wrapperElementType, {\n      ref: domEl\n    });\n  });\n}\n\n//\n\n// Handle R18 strict mode double mount at init\nfunction useEffectOnce(effect) {\n  var useEffectFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : useEffect;\n  var destroyFunc = useRef();\n  var effectCalled = useRef(false);\n  var renderAfterCalled = useRef(false);\n  var _useState3 = useState(0),\n    _useState4 = _slicedToArray(_useState3, 2);\n    _useState4[0];\n    var setVal = _useState4[1];\n  if (effectCalled.current) {\n    renderAfterCalled.current = true;\n  }\n  useEffectFn(function () {\n    // only execute the effect first time around\n    if (!effectCalled.current) {\n      destroyFunc.current = effect();\n      effectCalled.current = true;\n    }\n\n    // this forces one render after the effect is run\n    setVal(function (val) {\n      return val + 1;\n    });\n    return function () {\n      // if the comp didn't render since the useEffect was called,\n      // we know it's the dummy React cycle\n      if (!renderAfterCalled.current) return;\n      if (destroyFunc.current) destroyFunc.current();\n    };\n  }, []);\n}\n\nexport { index as default };\n"]},"metadata":{},"sourceType":"module"}